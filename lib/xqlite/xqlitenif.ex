defmodule XqliteNIF do
  use Rustler, otp_app: :xqlite, crate: :xqlitenif, mode: :release

  def open(_path, _opts \\ []), do: err()
  def open_in_memory(_path \\ ":memory:"), do: err()
  def open_temporary(), do: err()
  def query(_conn, _sql, _params \\ []), do: err()
  def query_cancellable(_conn, _sql, _params, _cancel_token), do: err()
  def execute(_conn, _sql, _params \\ []), do: err()
  def execute_cancellable(_conn, _sql, _params, _cancel_token), do: err()
  def execute_batch(_conn, _sql), do: err()
  def execute_batch_cancellable(_conn, _sql_batch, _cancel_token), do: err()
  def close(_conn), do: err()
  def get_pragma(_conn, _name), do: err()
  def set_pragma(_conn, _name, _value), do: err()
  def begin(_conn), do: err()
  def commit(_conn), do: err()
  def rollback(_conn), do: err()
  def savepoint(_conn, _name), do: err()
  def rollback_to_savepoint(_conn, _name), do: err()
  def release_savepoint(_conn, _name), do: err()
  def schema_databases(_conn), do: err()
  def schema_list_objects(_conn, _schema \\ nil), do: err()
  def schema_columns(_conn, _table_name), do: err()
  def schema_foreign_keys(_conn, _table_name), do: err()
  def schema_indexes(_conn, _table_name), do: err()
  def schema_index_columns(_conn, _index_name), do: err()
  def get_create_sql(_conn, _object_name), do: err()
  def last_insert_rowid(_conn), do: err()
  def create_cancel_token(), do: err()
  def cancel_operation(_token_resource), do: err()

  defp err, do: :erlang.nif_error(:nif_not_loaded)
end
